\section{Описание алгоритма и структур данных}

В данной работе реализуется алгоритм кодирования Шенона-Фано.
Работа выполнена на языке \verb|Python| версии \verb|3.8|.

\verb|ShanonFanoCoder| --- главный класс, 
позволяющий кодировать и декодировать строки
с момощью метеодов \verb|encode| и \verb|decode| соответственно.
Помимо этого, класс сохраняет полезную информацию после
кодирования/декодирования:

\begin{itemize}
    \item \verb|string| --- человекочитаемая строка.
    \item \verb|tree| --- дерево, с помощью которого происходит кодирование/декодирование.
    \item \verb|codes_table| --- маппинг символов и их кодов, созданный с помощью дерева.
    \item \verb|code_sep| --- код в виде списка кодов.
    \item \verb|code| --- код в виде единой непрерывной строки.
    \item \verb|string_size| --- битовый размер строки (с допущением, что один символ -- 8 бит).
    \item \verb|code_size| --- битовый размер кода.
    \item \verb|wrapping_coefficient| --- коэффициент сжатия.
\end{itemize}

Для кодирования/декодирования 
используется класс \verb|ShanonFanoTree|.
Объект класса может быть создан из 
таблицы вероятностей или из таблицы кодов.
В обоих случаях построение дерева происходит 
с помощью класса \verb|TreeBuilder| схожим образом:

\begin{enumerate}
    \item Создаётся корневой узел и вносится в очередь.
    \item Пока очередь не пуста
    \subitem Из очереди вытаскивается таблица и узел дререва,
    \subitem Если узел - лист (узлу назначен символ) - итерация пропускается.
    \subitem Таблица делится на 2 части -- левую и правую.
             Для таблицы вероятностей разделение идёт по сумме вероятностей, 
             чтобы они были приблизительно похожи.
             Для таблицы кодов разделение идёт по первому биту кода (1 или 0).
    \subitem Для каждой части создаётся свой узел. Если возможно, узлам назначается символ.
    \subitem Созданные узлы со своими таблицами отправляются обратно в очередь.
\end{enumerate}


\subsection{Кодирование}

Метод \verb|encode| принимает на вход строку,
которую нужно закодировать.
Из входной строки формируется маппинг символов
и их количества в тексте.
Нпример, для строки "aaa aaa bbbb" маппинг будет следующим:

\begin{lstlisting}
{
    'a': 6,
    'b': 4,
    ' ': 2,
}
\end{lstlisting}

Из таблицы вероятностей формируется дерево.
С помошью дерева создаётся таблица кодов.
С помощью таблицы кодов исходная 
строка кодируется в друх видах:
непрерывный код и код в виде списка.
Затем подсчитываются размер входной строки,
размер кода и коэффициент сжатия.

\subsection{Декодирование}

Метод \verb|decode| принимает на вход код,
который нужно декодировать, в виде непрерывной строки
или списка отдельных кодов и декодирующий объект -- дерево
или таблицу кодов.

Сначала загружается декодер.
Если это таблица кодов, то из неё формируется
дерево.
Сама таблица соохраняется отдельно.
Если это дерево -- то оно сохраняется и из
него достаётся таблица кодов.

После загружается код.
Если это непрерывная строка, то код разделяется
с помощью метода \verb|separate| класса \verb|ShanonFanoTree|.
Сам непрерывный код сохраняется отдельно.
Если это раздельный код, то он сохраняется 
и соединяется в непрерывный.

Потом создаётся инвертированая таблица код-символ
из таблицы символ-код.
По этой таблице раздельный код переводся в
декодированную строку.

Затем подсчитываются размер входной строки,
размер кода и коэффициент сжатия.